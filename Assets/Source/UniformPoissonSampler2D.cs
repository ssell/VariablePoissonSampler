using System;
using System.Collections.Generic;
using UnityEngine;

namespace VertexFragment
{
    /// <summary>
    /// A poisson disk sampler (blue noise) where the sample radius (minimum distance between points) is constant/uniform through the entire domain.
    /// </summary>
    public sealed class UniformPoissonSampler2D
    {
        // ---------------------------------------------------------------------------------
        // General Properties
        // ---------------------------------------------------------------------------------

        /// <summary>
        /// Is the poisson sampler currently in progress? If so, any calls to <see cref="Generate"/> will fail.
        /// </summary>
        public bool IsGenerating { get; private set; }

        /// <summary>
        /// The sample point generated by the sampler.
        /// </summary>
        public List<Vector2> SamplesList { get; private set; }

        /// <summary>
        /// The width of the domain of the sampler. This is the maximum <c>x</c> value in a generated point.
        /// </summary>
        public float Width { get; private set; }

        /// <summary>
        /// The height of the domain of the sampler. This is the maximum <c>y</c> value in a generated point.
        /// </summary>
        public float Height { get; private set; }

        /// <summary>
        /// The radius of the sample points, aka the minimum distance between points. 
        /// No two sampled points can be any closer than this value, but may be further away.
        /// </summary>
        public float Radius { get; private set; }

        /// <summary>
        /// The maximum number of attempts to generate a valid new point.
        /// The higher this value, the higher the coverage of the sampler but an increased runtime cost.
        /// </summary>
        public int RejectionLimit { get; private set; }

        /// <summary>
        /// The RNG used to generate the points in the sampled annulus.
        /// </summary>
        private System.Random Rng;

        // ---------------------------------------------------------------------------------
        // Spatial Grid Properties
        // ---------------------------------------------------------------------------------

        // Note that we implement our own Spatial Grid here and do not use SpatialGrid2D.
        // This is because we know there is a fixed radius and exactly one point per cell and so we are able
        // to take some short cuts for better performance that is not available in the more generic SpatialGrid2D.

        /// <summary>
        /// The length of each side of a cell in the underlying spatial grid.
        /// </summary>
        private float CellLength;

        /// <summary>
        /// The number of cells in the x-dimension in the underlying spatial grid.
        /// </summary>
        private int CellsPerX;

        /// <summary>
        /// The number of cells in the y-dimension in the underlying spatial grid.
        /// </summary>
        private int CellsPerY;

        /// <summary>
        /// The spatial grid used at as a lookup for faster "are there any nearby points?" queries.
        /// Stored as a 1D array, and accessed via <see cref="GetSpatialGridIndex(ref Vector2)"/>.
        /// </summary>
        private List<int> SpatialLookUp;

        /// <summary>
        /// List of candidate points that we will try to generate new points around.
        /// </summary>
        private List<int> ActiveList;

        // ---------------------------------------------------------------------------------
        // Methods
        // ---------------------------------------------------------------------------------

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rng">The RNG used to generate the random points.</param>
        /// <param name="sampleRadius">The minimum distance between points.</param>
        /// <param name="width">The width of the sampler domain. The maximum x value of a sampled position will be this.</param>
        /// <param name="height">The height of the sampler domain. The maximum y value of a sampled position will be this.</param>
        /// <param name="rejectionLimit">Number of generation attempts before a prospective point is rejected.</param>
        public UniformPoissonSampler2D(System.Random rng, float sampleRadius, float width, float height, int rejectionLimit = 30)
        {
            Rng = rng;
            Radius = sampleRadius;
            Width = width;
            Height = height;
            RejectionLimit = rejectionLimit;
        }

        public bool Generate()
        {
            if (IsGenerating)
            {
                return false;
            }

            Initialize();
            GenerateFirstPoint();

            while (ActiveList.Count > 0)
            {
                bool sampleFound = false;
                int activeIndex = GetRandomActiveListIndex();

                Vector2 currentSample = SamplesList[ActiveList[activeIndex]];

                for (int i = 0; i < RejectionLimit; ++i)
                {
                    Vector2 randomSample = GenerateRandomPointInAnnulus(ref currentSample);

                    if (!IsSampleOutOfBounds(ref randomSample) && !IsSampleNearOthers(ref randomSample))
                    {
                        AddSample(ref randomSample);
                        sampleFound = true;

                        break;
                    }
                }

                if (!sampleFound)
                {
                    ActiveList.RemoveUnorderedAt(activeIndex);
                }
            }

            return SignalStopGenerating(true);
        }

        private void Initialize()
        {
            IsGenerating = true;
            CellLength = Radius / MathUtils.Sqrt2;
            CellsPerX = (int)Math.Ceiling(Width / CellLength);
            CellsPerY = (int)Math.Ceiling(Height / CellLength);

            int totalCells = CellsPerX * CellsPerY;

            SpatialLookUp = new List<int>(totalCells);
            ActiveList = new List<int>(totalCells);
            SamplesList = new List<Vector2>();

            CollectionUtils.Fill(SpatialLookUp, -1, totalCells);
        }

        private void GenerateFirstPoint()
        {
            Vector2 sample = new Vector2(
                (float)Rng.NextDouble() * Width,
                (float)Rng.NextDouble() * Height);

            AddSample(ref sample);
        }

        private void AddSample(ref Vector2 sample)
        {
            int sampleIndex = SamplesList.Count;
            int spatialIndex = GetSpatialGridIndex(ref sample);

            SamplesList.Add(sample);
            ActiveList.Add(sampleIndex);
            SpatialLookUp[spatialIndex] = sampleIndex;
        }

        private int GetSpatialGridIndex(ref Vector2 sample)
        {
            int dx = (int)(sample.x / CellLength);
            int dy = (int)(sample.y / CellLength);

            return (dx + (dy * CellsPerX));
        }

        private int GetRandomActiveListIndex()
        {
            return Rng.Next(ActiveList.Count);
        }

        private Vector2 GenerateRandomPointInAnnulus(ref Vector2 point)
        {
            float min = Radius;
            float max = Radius * 2.0f;

            float distance = ((float)Rng.NextDouble() * (max - min)) + min;
            float angle = (float)Rng.NextDouble() * MathUtils.Pi2;

            return new Vector2(
                point.x + ((float)Math.Cos(angle) * distance),
                point.y + ((float)Math.Sin(angle) * distance));
        }

        private bool IsSampleOutOfBounds(ref Vector2 sample)
        {
            return (sample.x < 0.0f) || (sample.x > Width) || (sample.y < 0.0f) || (sample.y > Height);
        }

        private bool IsSampleNearOthers(ref Vector2 sample)
        {
            int prospectiveCell = GetSpatialGridIndex(ref sample);

            if ((prospectiveCell == -1) || SpatialLookUp[prospectiveCell] != -1)
            {
                return true;
            }

            for (int y = -1; y <= 1; ++y)
            {
                for (int x = -1; x <= 1; ++x)
                {
                    int neighbor = prospectiveCell + x + (y * CellsPerX);

                    if (IsSampleNearSampleInCell(neighbor, ref sample))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        private bool IsSampleNearSampleInCell(int lookupCell, ref Vector2 sample)
        {
            if ((lookupCell < 0) || (lookupCell >= SpatialLookUp.Count))
            {
                return false;
            }

            int cellSampleIndex = SpatialLookUp[lookupCell];

            if (cellSampleIndex == -1)
            {
                return false;
            }

            return Vector2.Distance(sample, SamplesList[cellSampleIndex]) <= Radius;
        }

        private bool SignalStopGenerating(bool success)
        {
            IsGenerating = false;
            return success;
        }
    }
}