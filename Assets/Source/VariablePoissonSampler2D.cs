using System;
using System.Collections.Generic;
using UnityEngine;

namespace VertexFragment
{
    /// <summary>
    /// A poisson disk sampler (blue noise) where the sample radius (minimum distance between points) is variable.<para/>
    /// If the radius is constant, then <see cref="UniformPoissonSampler2D"/> should be used instead for better performance.
    /// </summary>
    public sealed class VariablePoissonSampler2D
    {
        // ---------------------------------------------------------------------------------
        // Properties
        // ---------------------------------------------------------------------------------

        /// <summary>
        /// Is the poisson sampler currently in progress? If so, any calls to <see cref="Generate"/> will fail.
        /// </summary>
        public bool IsGenerating { get; private set; }

        /// <summary>
        /// The sample point generated by the sampler.
        /// </summary>
        public List<Vector2> Samples { get; private set; }

        /// <summary>
        /// The width of the domain of the sampler. This is the maximum <c>x</c> value in a generated point.
        /// </summary>
        public float Width { get { return MaxPoint.x; } }

        /// <summary>
        /// The height of the domain of the sampler. This is the maximum <c>y</c> value in a generated point.
        /// </summary>
        public float Height { get { return MaxPoint.y; } }

        /// <summary>
        /// The maximum number of attempts to generate a valid new point.
        /// The higher this value, the higher the coverage of the sampler but an increased runtime cost.
        /// </summary>
        public int RejectionLimit { get; private set; }

        /// <summary>
        /// Represents the bounds of the sampler region, on the range <c>[(0, 0), (MaxPoint.x, MaxPoint.y)]</c>.
        /// </summary>
        private Vector2 MaxPoint;

        /// <summary>
        /// The RNG used to generate the points in the sampled annulus.
        /// </summary>
        private System.Random Rng;

        /// <summary>
        /// 
        /// </summary>
        private SpatialGrid2D<int> SpatialGrid;

        /// <summary>
        /// List of candidate points that we will try to generate new points around.
        /// </summary>
        private List<int> ActiveList;

        // ---------------------------------------------------------------------------------
        // Delegates
        // ---------------------------------------------------------------------------------

        public delegate float GetRadiusAt(float x, float y);

        // ---------------------------------------------------------------------------------
        // Methods
        // ---------------------------------------------------------------------------------

        /// <summary>
        /// 
        /// </summary>
        /// <param name="rng">The RNG used to generate the random points.</param>
        /// <param name="width">The width of the sampler domain. The maximum x value of a sampled position will be this.</param>
        /// <param name="height">The height of the sampler domain. The maximum y value of a sampled position will be this.</param>
        /// <param name="rejectionLimit">Number of generation attempts before a prospective point is rejected.</param>
        public VariablePoissonSampler2D(System.Random rng, float width, float height, int rejectionLimit = 30)
        {
            Rng = rng;
            RejectionLimit = rejectionLimit;
            MaxPoint = new Vector2(width, height);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="minRadius">The minimum minimum distance between points. This is not enforced but used for optimizations.</param>
        /// <param name="maxRadius">The maximum minimum distance between points. This is not enforced but used for optimizations.</param>
        /// <returns></returns>
        public bool Generate(GetRadiusAt radiusFunc, float minRadius, float maxRadius)
        {
            if (IsGenerating)
            {
                return false;
            }

            Initialize(minRadius, maxRadius);
            GenerateFirstPoint();

            while (ActiveList.Count > 0)
            {
                bool sampleFound = false;
                int activeIndex = GetRandomActiveListIndex();

                Vector2 currentSample = Samples[ActiveList[activeIndex]];

                for (int i = 0; i < RejectionLimit; ++i)
                {
                    float radius = radiusFunc(currentSample.x, currentSample.y);
                    Vector2 randomSample = GenerateRandomPointInAnnulus(ref currentSample, radius);

                    if (SpatialGrid.AddIfOpen(Samples.Count, randomSample.x, randomSample.y, radius))
                    {
                        AddSample(ref randomSample);
                        sampleFound = true;

                        break;
                    }
                }

                if (!sampleFound)
                {
                    ActiveList.RemoveUnorderedAt(activeIndex);
                }
            }

            return SignalStopGenerating(true);
        }

        private void Initialize(float minRadius, float maxRadius)
        {
            IsGenerating = true;

            SpatialGrid = new SpatialGrid2D<int>(Width, Height, minRadius, maxRadius);
            ActiveList = new List<int>(SpatialGrid.CellsPerX * SpatialGrid.CellsPerY);
            Samples = new List<Vector2>();
        }

        private void GenerateFirstPoint()
        {
            Vector2 sample = new Vector2(
                (float)Rng.NextDouble() * MaxPoint.x,
                (float)Rng.NextDouble() * MaxPoint.y);

            AddSample(ref sample);
        }

        private void AddSample(ref Vector2 sample)
        {
            int sampleIndex = Samples.Count;

            Samples.Add(sample);
            ActiveList.Add(sampleIndex);
        }

        private int GetRandomActiveListIndex()
        {
            return Rng.Next(ActiveList.Count);
        }

        private Vector2 GenerateRandomPointInAnnulus(ref Vector2 point, float radius)
        {
            float min = radius;
            float max = radius * 2.0f;

            float distance = ((float)Rng.NextDouble() * (max - min)) + min;
            float angle = (float)Rng.NextDouble() * MathUtils.Pi2;

            return new Vector2(
                point.x + ((float)Math.Cos(angle) * distance),
                point.y + ((float)Math.Sin(angle) * distance));
        }

        private bool SignalStopGenerating(bool success)
        {
            IsGenerating = false;
            return success;
        }
    }
}
